#!/usr/bin/env bash
################################################################################
#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

#获取当前脚本名
target="$0"
# For the case, the executable has been directly symlinked, figure out
# the correct bin path by following its symlink up to an upper bound.
# Note: we can't use the readlink utility here if we want to be POSIX
# compatible.
#这里是检查执行的该脚本是不是软连，如果是软连那么一直找下去，直到找到最终指向的文件或超过100层软连就不找了。
#检查软连这个操作是为了啥呢？
#-L检查是否是软连  -z + 字符串  判断字符串变量是否是null
iteration=0
while [ -L "$target" ]; do
    if [ "$iteration" -gt 100 ]; then
        echo "Cannot resolve path: You have a cyclic symlink in $target."
        break
    fi
    ls=`ls -ld -- "$target"`
    #模式匹配,匹配\(.*\)里面的,一般模式匹配是这样：expr "abcd" : 'ab\(.*\)' ，这里为啥要加$呢?
    #为了回答这个问题，先学习下正则表达式和shell 模式匹配吧 https://www.cnblogs.com/pengdonglin137/p/3524471.html
    #正则表达式$，应该表示匹配输入字符串的结束位置，参考：https://www.cnblogs.com/yirlin/archive/2006/04/12/373222.html
    #这里拿到软连指向的文件路径，这样不停的拿到软连指向的路径，就可以拿到最终文件
    target=`expr "$ls" : '.* -> \(.*\)$'`
    iteration=$((iteration + 1))
done


#至此就拿到了软连指向的文件路径或超过100层软连后的文件路径

# Convert relative path to absolute path
#dirname 命令读取指定路径名删除最后一个“/”（ 斜杠）及其后面的字符，
# 保留其他部分，并写结果到标准输出。如果最后一个“/”后无 字符，dirname 命令使用倒数第二个“/”，并忽略其后的所有字符。
bin=`dirname "$target"`


#这里感觉是在添加环境变量
#这里加.  干啥呢？ 加点类似于你用：./test.sh执行脚本一样，如果没有加点，那就需要加上执行权限后才能直接执行，如果加了点，那就不需要赋予权限就可以执行了，
#eg: . /home/kafka/software/config.sh  可以执行，但直接/home/kafka/software/config.sh这样，
# 那么就会报：-bash: /home/kafka/software/config.sh: Permission denied，除非chmod赋予权限。
# get flink config
. "$bin"/config.sh

#$USER是获取当前账户.FLINK_IDENT_STRING是打日志的时候带上一个表示字符串（日志文件名带上该字符串），
# 如果没配置，那么就是以执行当前脚本的账户作为标识字符串
if [ "$FLINK_IDENT_STRING" = "" ]; then
        FLINK_IDENT_STRING="$USER"
fi

#这是干啥的？在config.sh里定义了constructFlinkClassPath方法，
# 把这个方法名赋予CC_CLASSPATH，然后在后面通过$CC_CLASSPATH就可以调用到该方法
CC_CLASSPATH=`constructFlinkClassPath`

#FLINK_LOG_DIR在config.sh脚本里定义了，FLINK_LOG_DIR作为存放日志的目录，怎么定义的呢？
#FLINK_IDENT_STRING就是前面说的标识字符串，没配置的话会用当前账户名来赋值。也就是说，日志文件名会带上账户名。
log=$FLINK_LOG_DIR/flink-$FLINK_IDENT_STRING-client-$HOSTNAME.log

#$FLINK_CONF_DIR在config.sh中定义了
log_setting=(-Dlog.file="$log" -Dlog4j.configuration=file:"$FLINK_CONF_DIR"/log4j-cli.properties -Dlog4j.configurationFile=file:"$FLINK_CONF_DIR"/log4j-cli.properties -Dlogback.configurationFile=file:"$FLINK_CONF_DIR"/logback.xml)

#config.sh中定义的变量FLINK_ENV_JAVA_OPTS、FLINK_ENV_JAVA_OPTS_CLI
# Add Client-specific JVM options
FLINK_ENV_JAVA_OPTS="${FLINK_ENV_JAVA_OPTS} ${FLINK_ENV_JAVA_OPTS_CLI}"

#JVM_ARGS、JAVA_RUN、FLINK_ENV_JAVA_OPTS、INTERNAL_HADOOP_CLASSPATHS都是在config.sh中定义的。
#exec 是啥
# Add HADOOP_CLASSPATH to allow the usage of Hadoop file systems
exec $JAVA_RUN $JVM_ARGS $FLINK_ENV_JAVA_OPTS "${log_setting[@]}" -classpath "`manglePathList "$CC_CLASSPATH:$INTERNAL_HADOOP_CLASSPATHS"`" org.apache.flink.client.cli.CliFrontend "$@"
